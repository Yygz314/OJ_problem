## Description
![image](https://github.com/user-attachments/assets/f3f7237d-80d6-4508-b948-7f66501ff8d0)
## Input
![image](https://github.com/user-attachments/assets/495b064b-20b9-45ce-a051-00d46b024ed7)
## Output
![image](https://github.com/user-attachments/assets/19ca9059-a0d1-4314-936d-50cff7b449cb)
## Sample Imput
```
8
20
42
0
``` 
## Sample Output
```
8 = 3 + 5
20 = 3 + 17
42 = 5 + 37
``` 
## Hint
-  ~~本题没有什么需要特别注意的地方~~ 正常写就可以
## Thinking
- 这是一道关于素数和哥德巴赫猜想的题目，根据题目的要求，只需要从小到大枚举奇数，并判断其是否为素数即可。
## Personal Solution
```
#include<bits/stdc++.h>
using namespace std;

int isprime(int n){  //判定是否为素数
	for(int i=2;i<=sqrt(n);i++){
		if(n%i==0) return 0;
	}
	return 1;
}

int main(){
	while(1){
		int a;
		cin>>a;
		if(a==0) break;  //多组测试数据直到0为止
		int flag=0;  //判断哥德巴赫猜想是否正确
		for(int i=3;i<=a/2;i+=2){
			if(isprime(i)==1&&isprime(a-i)==1){
				cout<<a<<" = "<<i<<" + "<<a-i<<endl;
				flag=1;
				break;  //找到就停止
			}
		}
		if(flag==0) cout<<"Goldbach's conjecture is wrong"<<endl;
	}
	return 0;
} 
```
## Analysing
- 这里的素数判定方法用了暴力枚举，从2到\( \sqrt{n} \)，时间复杂度为\[ O(a^{\frac{3}{2}) \]。不过对于此题数据可以通过。
- 而一种更有效的筛查素数方法是“埃氏筛法”。时间复杂度达到O(n)。
- “埃氏筛法”的核心思路就是当判定一个数为素数是可以筛去该素数的所有倍数的数（不可能为素数）。以下是该方法的简单代码：
```
const int len = 1000 //假定表长为1000
int prime[maxn],count=0;  //数组存放所有素数，count统计素数个数
bool p[len]={0};  //标记i是否为素数（是否被筛去）
void findprime(){
  for(int i=2;i<len;i++){
    if(p[i]==false){
      prime[count++]=i;
      for(int j=i+i;i<len;j+=i){
        p[j]=true;
      }
    }
  }  
}
  ```
