## Description
![image](https://github.com/user-attachments/assets/4b4e25b9-1b08-481a-8ef3-9c01a29c28b4)
## Input
![image](https://github.com/user-attachments/assets/315c2235-0c76-4403-9cff-8fe1c06631dd)
## Output
![image](https://github.com/user-attachments/assets/4491483e-6a66-49fe-b71a-1b3cf6db9498)
## Sample Input
```
2 5
1 7 2 10 9

6 11
62 63 54 66 65 61 57 56 50 53 48

0 0
``` 
## Sample Output
```
Case 1: 2
Case 2: 4
```
## Hint
- 思考什么情况下该回合是一定获胜的？
## Thinking
- 本题是一道较为经典的贪心策略题目。根据第二个样例分析，我们知道，纸牌的最大数是66时，如果我手上有66，该回合我一定最大；
而当66已经出掉以后，手上有65的人该回合一定最大；如样例2中，我手上接下来有63但没有64，所以按照至少的赢的回合数考虑，当
别人出64时我一定出的是63.
- 根据上述分析，我们可以先用一个数组num用于存储我手中的牌，在从最大的牌数开始递减遍历，如果该牌数在我手中，则获胜
的回合数count +1，否则-1.每回合结束比较一下count是否超过最大回合数。
## Personal Solution
```
#include<bits/stdc++.h>
using namespace std;
int num[1005];
int main(){
	int t=1,m,n;
	while(~scanf("%d%d",&m,&n)){
		if(m==0&&n==0) break;
		memset(num,0,sizeof(num));
		for(int i=0;i<n;i++){
			int a;
			scanf("%d",&a);
			num[a]=1;
		}
		int count=0,ans=0;
		for(int i=m*n;i>=1;i--){
			if(num[i]==1) count++;
			else count--;
			ans=max(ans,count);
		}
		printf("Case %d: %d\n",t,ans);
		t++;
	}
}
```
## Analysing
