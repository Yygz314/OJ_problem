## Description
![image](https://github.com/user-attachments/assets/58c4d3b0-eb6e-4a08-b52a-f96903111f1b)
## Input
![image](https://github.com/user-attachments/assets/6cd84ad8-a4df-4f45-8afc-57041ac1b989)
## Output
![image](https://github.com/user-attachments/assets/7ed28b5d-3b67-4f0c-845c-3ac17b9cd919)
## Sample Input
```
100
``` 
## Sample Output
```
354224848179261915075
```
## Hint
- 对于超大的数据该如何处理？
## Thinking
- 这道题思路很简单。就是在斐波那契数列的背景下考察大数的加法运算。
- 在c/c++中，大数的计算需要从加法的定义出发，逐位相加，按需进位。
- 我们首先考虑用自定义函数将读取的字符串大数存储到数组中（逆序存放），然后进行大数相加，大于10就进行进位处理，
最后我们再倒序输出即可。
- 在此题背景下，需要再通过两个数组存放第n-1和第n-2个大数。
## Personal Solution
```
#include<bits/stdc++.h>
using namespace std;
struct bign{  //用于存储大数，并记录长度
	int d[1000];
	int len;
	bign(){
		memset(d,0,sizeof(d));
		len=0;
	}
};

//将字符串转化为数组大数
bign change1(string a){
	bign num;
	num.len=a.length();
	for(int i=0;i<a.length();i++){
		num.d[i]=a[a.length()-i-1]-'0';	//逆序赋值 
	}
	return num;
}

//两个大数相加
bign add(bign a,bign b){
	bign c;
	int carry=0;	//carry是进位大小
	for(int i=0;i<a.len||i<b.len;i++){
		int temp=a.d[i]+b.d[i]+carry;
		c.d[c.len++]=temp%10;
		carry=temp/10;
	} 
	if(carry!=0){
		c.d[c.len++]=carry;
	}
	return c;
}

//输出相加结果
void print(bign a){
	for(int i=a.len-1;i>=0;i--){
		cout<<a.d[i];
	}
	cout<<endl;
}

int main(){
	bign a,b,ans;  
	int N;
	while(~scanf("%d",&N)){
		if(N==1||N==2) cout<<1<<endl;
		else{
			a.len=1,a.d[0]=1;
			b.len=1,b.d[0]=1;
			for(int i=3;i<=N;i++){
				ans=add(a,b);
				b=a;
				a=ans;
			}
			print(ans);
		} 
	}
	return 0;
}
```
## Analysing
